<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
      <meta charset="utf-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Sufficiently Random/NixOs and moving to Formal Methods</title>
      <!-- Latest compiled and minified CSS -->

      <link rel="stylesheet" type="text/css" href="../css/stylesheet.css" media="screen" />
      <link rel="stylesheet" type="text/css" href="../css/pygment_trac.css" media="screen" />
      <link rel="stylesheet" type="text/css" href="../css/pandoc.css" media="screen" />

      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>

    <body>

      <header>
        <div class="container">
          <h1>~/mvc/<a href="../">sufficiently_random</a>/NixOs and moving to Formal Methods</h1>
        </div>
        <div><h2></h2></div>
      </header>

      <div class="container">

          <div class="info">
    Posted on January 29, 2014
    
</div>
<h2>NixOs and moving to Formal Methods</h2>
<p>I figured I’d write a post about my pending switch from Arch Linux to NixOS. While Arch has been a <em>fantastic</em> distro, the transition from Arch to Nix in some sense represents my new found appreciation (addiction) for <a href="http://en.wikipedia.org/wiki/Formal_methods">formal methods</a>.</p>
<p>Other examples include my continued transition from Python<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>/C to Haskell. While I can’t imagine myself completely abandoning Python (or C), being able to rely on the infrastructure for proving certain semantic features in the code is a huge plus (no side effects and real type consistency, not that lame stuff in most mainstream languages). In the same vein, NixOS appears to offer a solid theoretical basis for managing configurations and packages. In theory it also allows faster deployment, reproducible setups, and <em>version control</em> at almost every relevant part of system configuration. There are other tools to do this (salt, puppet, etc), but they tend to operate on what I’ve found to be a more stateful approach.</p>
<p>I’ll probably write a longer (more indepth) post about my thoughts after using it for awhile….</p>
<p>As always feel free to follow me on twitter <span class="citation">@mvcisback</span></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Although the <a href="http://www.mypy-lang.org/">mypy</a> project may satisfy alot of my secret desires for python<a href="#fnref1">↩</a></p></li>
</ol>
</div>

      </div>

      <div class="footer">
        <div>
          <a href="../atom.xml">
            <img border="0" alt="atom.xml" src="../images/Feed-icon.svg" width="10" height="30" style="background-color: transparent" ; />
            Contact: <a href="https://twitter.com/mvcisback">@mvcisback</a>
            Code: <a href="https://github.com/mvcisback">Github</a>

          </div>
          <div>
            this site = 
            <a href="http://jaspervdj.be/hakyll">Hakyll</a> + 
            <a href="http://sundaykofax.github.io/baby-legs/">Theme</a> +
            <a href="http://pages.github.com/">Github Pages</a> +
            <a href="https://github.com/mvcisback/mvcisback.github.com">Source</a> +
            too much time
          </div>
      </div>
    </body>
</html>
